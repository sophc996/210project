
# Premier League Match Analysis

I changed my project idea from my initial proposal because I found that my initial dataset and approach was too computationally costly: I originally had a dataset of 498k rows that computed connections between hockey players across different leagues based on who else they had played with who acted as a bridge between two players, using breadth-first-search to find degrees of separation. However, it ended up being too large and paring it down made some connections impossible. I also struggled to handle duplicate player names and diacritics/accents in my String encoding, so I ended up going back to the dataset from my original search: a record of every Premier League match from 1992-93, when the league was started, to the 2022-23 season.

My initial goal for this project was to use preliminary data analysis to find out if COVID seasons in the Premier League had any effect on home advantage. The effect of home crowd support on match results in the Premier League is well-documented –  and considering that during the COVID seasons (part of 2019-20 and the entirety of 2020-21) matches took place behind closed doors, I was curious to see if that affected the home vs away win-rates of teams in the PL. I planned to use the plotters crate to visualize my data as well, but for some reason I wasn’t able to install the crate, so I did my best without it.

I split my code into a main and a mod file (game.rs) which contained all the information to process the csv, create Game and DataFrame structs, and print information about individual games. I started with a read_csv method that took in an empty DataFrame struct to store all the data from the csv (the headers and individual Game structs as a Vector of Games). Indexing by the column number, I created individual vectors for each column and pushed the value from that column-row pairing to the vector, so I could collect each vector into my Game struct. I then pushed each Game struct into the games field of my DataFrame, and returned a Result enum containing a vector of Games matching the one that belonged to my self.games field.

Since I wanted to do a lot of team and season-specific computations, I refactored a lot of my code to create functions that took in each team/season and then used those in my general functions when I wanted to compute an average across teams or seasons. I passed the same vector of Games into all of my functions, and then used nested loops to check if that game was in the correct season and involved the named team. I started by computing the most successful teams using two measures: overall win percentage and number of seasons in the Premier League, which uses a relegation system where the least winning teams in each season are relegated to the next-highest league in the English football system.

For both my top_percent() and top_appearances() functions, I made helper functions that computed the overall win percentage for a given team in a given range of seasons, and the number of seasons the team appeared in that range. In my team_seasons() function, I initially used a HashSet to keep track of the seasons without repeats, but because HashSets are ordered by the hash function buckets and not necessarily the value of each element, I ended up changing this to a vector of seasons, and just used .contains to check if that season was already in the given vector. To find the top ten most successful teams by both metrics, I looped through every team in the 1993-2023 season range and sorted my vectors by the relevant values. 

I created functions to calculate a season’s overall home, away, and draw result percentages, and made a test to ensure that they added up to 100. This was used to find the season with the lowest home win rate and how much of an outlier it was compared to the average home win rate (see output). I found that, consistent with my hypothesis, the 2020-21 season had the lowest home win rate – the only season where the home win rate was lower than the away win rate. This was the only season when games were played entirely without spectators (only a few weeks of the 2019-20 season had no spectators, and in 2021-22, the league welcomed back full stadiums of fans). Remarkably, the home win rate in 2021 was about 8% lower than the overall average, and almost 3.5% lower than the second-lowest season (2016). So while more rigorous statistical analysis would be needed to control for other variables, this shows some speculative association between COVID season protocols and league-wide home advantage. 

I also calculated the average goals scored per game in each season and found that 2023 had the highest GPG average, which makes sense in context with sports journalists analyzing the increase in offensive tactics over the past few years, while defensive and goalkeeping techniques have not kept pace. For fun, I also looked at a given team’s highest game-winning interval across a given season range.

In my main function, I printed most of my information about the top n (10) most successful teams, using the functions I mentioned above. I also described the home win-rate change I had noticed during the COVID season relative to that season’s draw and away-win rates. Lastly, I created a user input function that took in a team and a range of seasons, then provided some information about: a) what seasons in that range the team had played in, if any; b) the team’s biggest win interval over that range, and information about the game where it took place, using my game print() method; and c) their win rate in that range. At various points in the user input function, I used the Result enum to handle possible errors, such as the season range not falling within the given seasons, the user input team not matching the team names, and the team not playing in the Premier League during that range.

I created two main tests for my program. The first tested the functionality of my home_pct, away_pct, and draw_pct functions. In theory, since these were calculating the proportion of games in a given season that ended in a home win, away win, and draw respectively (which I then multiplied by 100 to get a percentage), they should add up to 100. To accomplish this in my test, I inputted a random season (2023) and added the percentages from each function to a total_rate variable, which I then used the assert_eq! macro to compare to 100.0, and this test passed.

I also tested whether my team_seasons function worked: given a team and a season range, I wanted it to return a tuple containing a Vec<usize> of all the seasons in that range where the team had appeared, and a usize that counted those seasons. I knew that several teams had appeared in all 31 of the Premier League’s seasons from 1992-93 to 2022-23, including Manchester United, so I passed their team name into this function to ensure that it matched the overall number of seasons.